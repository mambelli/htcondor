#!/bin/bash

################################################################################
# blahp-over-ssh shim script
#
# command [options] remote_hostname [remote command] [remote options/arguments]
#
# Options:
#   see usage string 
#
# Arguments:
#   mandatory: remote_hostname
#
# Remote options/arguments are passed along
#
# Assumes public/private key pair is already created and exists on host
#
# Exits with 0 on success, 1 if wrong arguments, < 0 if ssh-add failed, > 0 if ssh failed
################################################################################

#Defaults
REMOTE_CMD=""
REMOTE_HOSTNAME=""
REMOTE_USER=`whoami`
# Fix the home directory when spawned from a root process
unset HOME
export HOME=`echo ~`
# Needs '~' because resolved on remote site
REMOTE_GLITE="~/bosco/glite"
# We do this in case $HOME isn't set properly
PASSPHRASE_LOCATION=`echo ~/.bosco/.pass`
PRIVATE_KEY_LOCATION=`echo ~/.ssh/bosco_key.rsa`


# Parse command line arguments 
PROG_NAME=$0
USAGE="Usage: $PROG_NAME [options] remote_hostname REMOTE_CMD [remote options and arguments]\n \
$PROG_NAME [options] remote_hostname [remote options and arguments]\n \
Options: \n \
 --rgahp-user REMOTE_USER \tuser name on the remote host\n \
 --rgahp-key PRIVATE-KEY-PATH \tlocation of ssh private key (~/.ssh/bosco_key.rsa)\n \
 --rgahp-nokey  \t\tno ssh private key or key already enabled (same as empty rgahp-key)\n \
 --rgahp-pass PASSPHRASE \tlocation of passphrase protecting ssh private key (~/.bosco/.pass)\n \
 --rgahp-nopass \t\tno passphrase protecting ssh private key (same as empty rgahp-pass)\n \
 --rgahp-glite PATH \tpath to the directory of the script (~/bosco/glite)\n \
 --rgahp-script SCRIPT \tpath to script to start up blahp (PATH/bin/batch_gahp)\n \
 --help, -h \t\t\tprint this\n \
 remote_hostname: USER@HOST same string that can be used to ssh to the host\n \
 remote options and arguments are passed to the REMOTE_CMD
 REMOTE_CMD can be expressed as argument or option
"

## START WORKAROUND SECTION
inserted_par=""
# The remote command should be added exactly after the hostname or as a parameter.
# Since there may be options before (for remote_gahp) and after (for REMOTE_CMD) that, this may be tricky
# The suggestion is to use the option "--rgahp-script REMOTE_CMD" at the beginning (before any parameter or option),
# this would allow to remove this whole WORKAROUND SECTION
# 
# Removing REMOTE_CMD that is added in second position (HTCondor <= 8.2.1)
# This interferes with the options 
if [ "x$1" != "x--rgahp-script" ]; then
    if [[ "x$2" == "xbatch_gahp" || "#$2" == "xcondor_ft-gahp" ]]; then 
        inserted_par="$2"
        set -- "$1" "${@:3}" 
    fi
fi
# Removing REMOTE_CMD that is added in last position (HTCondor >= 8.2.2)
# This interferes with the options for the REMOTE_CMD
if [[ "x${@: -1}" == "xbatch_gahp" || "#${@: -1}" == "xcondor_ft-gahp" ]]; then 
    inserted_par="${@: -1}"
    set -- "${@:1: $#-1}" 
fi
## END WORKAROUND SECTION




getopt -T > /dev/null
if [ $? -ne 4 ]; then
    # Mac OS X doesn't have GNU getopt, so not fancy argument checking here
    # the exit code test is suggested by man getopt, better than `uname` = "Darwin"
    # Getopt replacement to make long options work
    # TODO Still options aren't checked on Mac OS X. We should fix that sometime.
    arg_found=1
    skip_next=1
    for i; do
        # $i is $1  
        if [ $arg_found -eq 0 ]; then
            set -- "${@:2}" "$i"
        else
            if [[ $skip_next -eq 0 || $i =~ ^--.+ ]]; then
                # option or argument
                if [[ "--rgahp-user,--rgahp-key,--rgahp-pass,--rgahp-glite,--rgahp-script" == *"$i"* ]]; then
                    #echo "Long option"
                    skip_next=0
                else 
                    skip_next=1
                fi
                set -- "${@:2}" "$i"
            else
                # echo "Found!"
                arg_found=0
                if [ -n "$inserted_par" ]; then
                    set -- "${@:2}" -- "$i" "$inserted_par"
                else
                    set -- "${@:2}" -- "$i" 
                fi
            fi
        fi
    done
else
    TEMP=`getopt -o +h --long help,rgahp-user:,rgahp-key:,rgahp-nokey,rgahp-pass:,rgahp-nopass,rgahp-glite:,rgahp-script: -- "$@"`

    if [ $? != 0 ] ; then echo -e "$USAGE" >&2 ; exit 1 ; fi

    eval set -- "$TEMP"
fi


# Remote hostname is mandatory
# It is the first argument after the rgahp options
# 
tmp_found=1
for i; do
	if [ $tmp_found -eq 0 ] ; then 
		if [ "x${REMOTE_HOSTNAME}" = "x" ] ; then
		    REMOTE_HOSTNAME=`echo "$i" | sed 's/.*@//'`
		    echo "$i" | grep -q '@'
		    if [ $? -eq 0 ] ; then
		        REMOTE_USER=`echo "$i" | sed 's/@.*//'`
		    fi
		else
		    REMOTE_CMD="$i"
		    break
		fi
	fi
	if [ "$i" = "--" ]; then tmp_found=0; fi
done

if [ "X${REMOTE_HOSTNAME}X" = "XX" ] ; then echo -e "$USAGE" >&2 ; exit 1 ; fi

# If the REMOTE_CMD was found by the workaround this takes precedence to the positional parameter
if [ -n "$inserted_par" ]; then
    REMOTE_CMD="$inserted_par"
fi



# Go through possible remote hosts and set eventual host default
for host in "${REMOTE_HOSTS[@]}" ; do

	# split string on ' '
	parts=($host)

	# check if this is a host we care about
	if [ "$REMOTE_HOSTNAME" == ${parts[0]} ] ; then
		#REMOTE_HOSTNAME=${parts[0]}
		REMOTE_GLITE=${parts[1]}
		PASSPHRASE_LOCATION=${parts[2]}
		PRIVATE_KEY_LOCATION=${parts[3]}
		break
	fi
done

# Set values specified in command line arguments (these override defaults and REMOTE_HOSTS)
for i; do
	case "$i" in
		-h | --help  ) echo -e "$USAGE"
			exit 0;;
		--rgahp-user  ) REMOTE_USER="$2"
			shift 2;;
		--rgahp-nokey  ) PRIVATE_KEY_LOCATION=""
			shift ;;
		--rgahp-key  ) PRIVATE_KEY_LOCATION="$2"
			shift ; shift  ;;
		--rgahp-pass  ) PASSPHRASE_LOCATION="$2"
			shift 2;;
		--rgahp-nopass  ) PASSPHRASE_LOCATION=""
			shift ;;
		--rgahp-glite ) REMOTE_GLITE="$2"
			shift 2;;
		--rgahp-script ) REMOTE_CMD="$2"
			shift 2;;
		--  ) shift; break ;;
	esac
done

# remove hostname from arglist
shift

# remove the remote command from the arglist (it may not be there depending on how it was passed)
[ "x$1" = "x${REMOTE_CMD}" ] && shift



##### Handling authentication #####
# Start and init ssh agent if key file is specified


# if a ssh key is required, start up a ssh-agent and do ssh-add
if [ -n "$PRIVATE_KEY_LOCATION" -a -f "$PRIVATE_KEY_LOCATION" ] ; then
	# start the ssh-agent
	eval `ssh-agent -s` 1>&2

	# Call the external program to do ssh-add
        # If a passphrase is required pass it to the script
        if [ -n "$PASSPHRASE_LOCATION" ]; then 
	    bosco_ssh_start --key "$PRIVATE_KEY_LOCATION" --pass "$PASSPHRASE_LOCATION"
        else
	    bosco_ssh_start --key "$PRIVATE_KEY_LOCATION" --nopass
        fi
	ADD_STATUS=$?

	# check if ssh-add failed
	if [ $ADD_STATUS != 0 ] ; then
		eval `ssh-agent -sk` 1>&2
		exit $ADD_STATUS
	fi
fi


##### Running remote command and cleanup #####

# use BatchMode so we fail if a password is requested
#echo "** Follows output of: ssh -o \"BatchMode yes\" $REMOTE_USER@$REMOTE_HOSTNAME /bin/bash -c \"'GLITE_LOCATION=$REMOTE_GLITE $REMOTE_GLITE/bin/batch_gahp $*'\""
if [ "batch_gahp" = "${REMOTE_CMD}" ] ; then
    ssh -o "BatchMode yes" $REMOTE_USER@$REMOTE_HOSTNAME /bin/bash -l -c "'GLITE_LOCATION=$REMOTE_GLITE $REMOTE_GLITE/bin/batch_gahp $*'"
    SSH_STATUS=$?
elif [ "condor_ft-gahp" = "${REMOTE_CMD}" ] ; then
    # We need to set up a tunnel from the remote machine for the file
    # transfer TCP connections. If we knew that both sides were running
    # OpenSSH 5.2p1 or later, we could have ssh pick the port on the
    # remote end. But we don't, so we pick a random port and hope it's
    # not already in use.
    # We mimic the message that newer versions of OpenSSH print when
    # binding a dynamic port for tunneling. The gridmanager looks for
    # this message to know which port to tell the ft-gahp to use.
    # If the local OpenSSH is 4.4p1 or later (we check for 5.0 or later
    # for simplicity), then we can use ExitOnForwardFailure and try
    # several random ports in case we get unlucky on the first attempt.
    # We extract the IP and port on which the gridmanager can be
    # contacted from $CONDOR_INHERIT.
    GRIDMANAGER_ADDRESS=`echo "$CONDOR_INHERIT" | sed 's/[^<]*<\([^?>]*\).*/\1/'`
    SSH_STATUS=255
    if [[ `ssh -V 2>&1` =~ ^OpenSSH_[5-9].* ]] ; then
        SSH_ARGS="-o ExitOnForwardFailure=yes"
        tries=3
    else
        tries=1
    fi
    while ((tries-- > 0 && SSH_STATUS == 255)) ; do
        let port=${RANDOM}+32768
        ssh $SSH_ARGS -R $port:$GRIDMANAGER_ADDRESS -o "BatchMode yes" $REMOTE_USER@$REMOTE_HOSTNAME /bin/bash -l -c "'echo Allocated port $port for remote forward to 1>&2 ; CONDOR_CONFIG=$REMOTE_GLITE/etc/condor_config.ft-gahp $REMOTE_GLITE/bin/condor_ft-gahp -f $*'"
        SSH_STATUS=$?
    done
else
    echo "Unknown remote command (${REMOTE_CMD})" 1>&2
    SSH_STATUS=1
fi

# kill the ssh-agent if it exists
eval `ssh-agent -sk` 1>&2

exit $SSH_STATUS
